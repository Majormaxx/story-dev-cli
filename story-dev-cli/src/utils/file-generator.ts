/**
 * File generation utilities
 */

import * as fs from 'fs-extra';
import * as path from 'path';
import { getContractAddresses } from './contracts';
import { getNetworkConfig } from './network';
import { generateGitignore, generateEnvExample, formatPrivateKey } from './security';

export interface ProjectConfig {
  projectName: string;
  template: 'registration' | 'licensing' | 'royalty';
  network: 'mainnet' | 'testnet';
  privateKey: string;
  targetPath: string;
}

/**
 * Generate .env file with all configuration
 */
export function generateEnvFile(config: ProjectConfig): string {
  const contracts = getContractAddresses(config.network);
  const networkConfig = getNetworkConfig(config.network);
  
  return `# Story Protocol Configuration
# Generated by @story-protocol/cli

# Network Configuration
NEXT_PUBLIC_NETWORK=${config.network}
NEXT_PUBLIC_CHAIN_ID=${networkConfig.chainId}
NEXT_PUBLIC_RPC_URL=${networkConfig.rpcUrl}

# Private Key (KEEP THIS SECRET!)
PRIVATE_KEY=${formatPrivateKey(config.privateKey)}

# Story Protocol Core Contracts
NEXT_PUBLIC_IP_ASSET_REGISTRY=${contracts.IPAssetRegistry}
NEXT_PUBLIC_LICENSING_MODULE=${contracts.LicensingModule}
NEXT_PUBLIC_ROYALTY_MODULE=${contracts.RoyaltyModule}
NEXT_PUBLIC_DISPUTE_MODULE=${contracts.DisputeModule}
NEXT_PUBLIC_GROUPING_MODULE=${contracts.GroupingModule}
NEXT_PUBLIC_LICENSE_REGISTRY=${contracts.LicenseRegistry}
NEXT_PUBLIC_LICENSE_TOKEN=${contracts.LicenseToken}
NEXT_PUBLIC_PIL_TEMPLATE=${contracts.PILicenseTemplate}

# Story Protocol Workflow Contracts
NEXT_PUBLIC_REGISTRATION_WORKFLOWS=${contracts.RegistrationWorkflows}
NEXT_PUBLIC_LICENSE_ATTACHMENT_WORKFLOWS=${contracts.LicenseAttachmentWorkflows}
NEXT_PUBLIC_ROYALTY_WORKFLOWS=${contracts.RoyaltyWorkflows}
NEXT_PUBLIC_SPG_NFT_IMPL=${contracts.SPGNFTImpl}

# Block Explorer
NEXT_PUBLIC_BLOCK_EXPLORER=${networkConfig.blockExplorer}
`;
}

/**
 * Copy template directory to target location
 */
export async function copyTemplate(
  templateName: string,
  targetPath: string,
  config: ProjectConfig
): Promise<void> {
  const templatePath = path.join(__dirname, '../../templates', templateName);
  
  // Check if template exists
  if (!await fs.pathExists(templatePath)) {
    throw new Error(`Template "${templateName}" not found at ${templatePath}`);
  }
  
  // Copy template files
  await fs.copy(templatePath, targetPath, {
    filter: (src) => {
      // Skip node_modules and build directories
      return !src.includes('node_modules') && !src.includes('dist') && !src.includes('.next');
    },
  });
}

/**
 * Generate all project files
 */
export async function generateProject(config: ProjectConfig): Promise<void> {
  const { targetPath, network } = config;
  
  // Sanitize target path to prevent directory traversal
  const safePath = sanitizePath(process.cwd(), targetPath);
  
  // Create project directory
  await fs.ensureDir(safePath);
  
  // Copy template
  await copyTemplate(config.template, safePath, config);
  
  // Generate .env file
  const envContent = generateEnvFile(config);
  await fs.writeFile(path.join(safePath, '.env'), envContent);
  
  // Generate .env.example
  const envExampleContent = generateEnvExample(network);
  await fs.writeFile(path.join(safePath, '.env.example'), envExampleContent);
  
  // Generate .gitignore
  const gitignoreContent = generateGitignore();
  await fs.writeFile(path.join(safePath, '.gitignore'), gitignoreContent);
  
  // Update package.json name
  const packageJsonPath = path.join(safePath, 'package.json');
  if (await fs.pathExists(packageJsonPath)) {
    const packageJson = await fs.readJson(packageJsonPath);
    packageJson.name = config.projectName;
    await fs.writeJson(packageJsonPath, packageJson, { spaces: 2 });
  }
}

/**
 * Validate project name with enhanced security checks
 */
export function validateProjectName(name: string): boolean {
  // Check for empty or whitespace-only names
  if (!name || name.trim().length === 0) {
    return false;
  }
  
  // Prevent path traversal patterns
  if (name.includes('..') || name.includes('/') || name.includes('\\')) {
    return false;
  }
  
  // Prevent leading dots or dashes (hidden files or invalid package names)
  if (name.startsWith('.') || name.startsWith('-')) {
    return false;
  }
  
  // Must be alphanumeric with hyphens/underscores only
  // Length between 1-214 characters (npm package name limit)
  return /^[a-z0-9][a-z0-9-_]{0,213}$/i.test(name);
}

/**
 * Sanitize path to prevent directory traversal
 */
export function sanitizePath(basePath: string, userPath: string): string {
  const normalized = path.normalize(userPath).replace(/^(\.\.[\/\\])+/, '');
  const resolved = path.resolve(basePath, normalized);
  
  // Ensure the resolved path is within the base path
  if (!resolved.startsWith(path.resolve(basePath))) {
    throw new Error('Invalid path: directory traversal detected');
  }
  
  return resolved;
}

/**
 * Check if directory exists and is empty
 */
export async function isDirectoryEmpty(dirPath: string): Promise<boolean> {
  if (!await fs.pathExists(dirPath)) {
    return true;
  }
  
  const files = await fs.readdir(dirPath);
  return files.length === 0;
}
